"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.oas = exports.ResponseValidationError = exports.RequestValidationError = exports.ChowError = void 0;
const config_1 = require("./config");
const oas3_chow_chow_1 = require("oas3-chow-chow");
Object.defineProperty(exports, "ChowError", { enumerable: true, get: function () { return oas3_chow_chow_1.ChowError; } });
Object.defineProperty(exports, "RequestValidationError", { enumerable: true, get: function () { return oas3_chow_chow_1.RequestValidationError; } });
Object.defineProperty(exports, "ResponseValidationError", { enumerable: true, get: function () { return oas3_chow_chow_1.ResponseValidationError; } });
const openapi_ui_1 = require("./openapi-ui");
const jsonfile = require("jsonfile");
const yaml = require("js-yaml");
const fs = require("fs");
const oasValidator = require("oas-validator");
const compose = require("koa-compose");
const qs = require("qs");
const util = require("util");
const readFile = util.promisify(fs.readFile);
async function oas(cfg) {
    const config = config_1.validateConfig(cfg);
    const { compiled, doc } = await compileOas(config);
    const validatorMW = async (ctx, next) => {
        try {
            const validRequest = compiled.validateRequestByPath(ctx.path, ctx.request.method, {
                header: ctx.request.header,
                query: qs.parse(ctx.request.querystring, config.qsParseOptions),
                path: ctx.params,
                cookie: ctx.cookies,
                body: ctx.request.body,
            });
            // Store coerced values
            ctx.oas = {
                request: {
                    query: validRequest.query,
                    params: validRequest.path,
                    header: validRequest.header,
                },
                operationId: validRequest.operationId
            };
        }
        catch (err) {
            config.errorHandler(err, ctx);
        }
        await next();
        if (config.validateResponse) {
            try {
                compiled.validateResponseByPath(ctx.path, ctx.method, {
                    status: ctx.status,
                    header: ctx.response.header,
                    body: ctx.body
                });
            }
            catch (err) {
                config.errorHandler(err, ctx);
            }
        }
    };
    const composedMW = async (ctx, next) => {
        if (config.enableUi && ctx.path === config.endpoint) {
            ctx.body = doc;
            return;
        }
        if (config.enableUi && ctx.path === config.uiEndpoint) {
            ctx.body = openapi_ui_1.openapiUI({
                title: doc.info ? doc.info.title : 'openapi UI',
                url: config.endpoint,
                swaggerUiBundleBasePath: config.swaggerUiBundleBasePath
            });
            return;
        }
        if (!config.validatePaths.some(path => ctx.path.startsWith(path))) {
            // Skip validation if no path matches
            return next();
        }
        const middlewares = [];
        const requestContentTypes = compiled.getDefinedRequestBodyContentType(ctx.path, ctx.request.method);
        const matchedContentType = ctx.request.is(requestContentTypes);
        if (requestContentTypes.length && config.requestBodyHandler && matchedContentType && typeof matchedContentType === 'string') {
            // We need to find the most specific matched handler
            const parts = matchedContentType.split('/');
            if (config.requestBodyHandler[matchedContentType]) {
                middlewares.push(config.requestBodyHandler[matchedContentType]); // For a specific match like `application/json`
            }
            else if (config.requestBodyHandler[`${parts[0]}/*`]) {
                middlewares.push(config.requestBodyHandler[`${parts[0]}/*`]); // For a match like `application/*`
            }
            else if (config.requestBodyHandler[`*/${parts[1]}`]) {
                middlewares.push(config.requestBodyHandler[`*/${parts[1]}`]); // For a match like `*/json`
            }
            else if (config.requestBodyHandler['*/*']) {
                middlewares.push(config.requestBodyHandler['*/*']); // For a global type match defined as `*/*`
            }
        }
        middlewares.push(validatorMW);
        await compose(middlewares).call(this, ctx, next);
    };
    return composedMW;
}
exports.oas = oas;
async function loadFromFile(file) {
    if (!file) {
        throw new Error("Missing file path");
    }
    switch (true) {
        case file.endsWith('.json'): {
            return jsonfile.readFile(file);
        }
        case file.endsWith('.yml') || file.endsWith('.yaml'): {
            return yaml.safeLoad(await readFile(file, { encoding: 'utf8' }));
        }
        default:
            throw new Error('Unsupported file format');
    }
}
async function compileOas(config) {
    let openApiObject = config.spec || await loadFromFile(config.file);
    try {
        await oasValidator.validateInner(openApiObject, config.oasValidatorOptions || {});
    }
    catch (err) {
        throw new Error('Invalid Openapi document' + err.message);
    }
    return {
        compiled: new oas3_chow_chow_1.default(openApiObject, config.validationOptions),
        doc: openApiObject,
    };
}
//# sourceMappingURL=index.js.map